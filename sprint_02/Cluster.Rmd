---
title: "Clustering"
output: html_notebook
---

# Disclaimer: Urheberrecht
Die in den Analysen verwendeten Daten wurden uns von Prof. Dr.-Ing. Martin Wölker ([Hochschul-Profilseite](https://www.hs-kl.de/hochschule/profil/personenverzeichnis/detailanzeige-personen/person/martin-woelker)) zur Verfügung gestellt. Die Daten sind auf Herrn Wölkers Blog ([Martins wahre Logistik](https://martins-wahre-logistik.blogspot.com/2022/10/logistics-case-studies-der-lieferschein.html)) auffindbar. Zum gegenwärtigen Zeitpunkt (Stand: 07.12.2022) sind die Daten wie folgt lizenziert: CC BY-NC-SA



```{r include=FALSE}
library(DBI)
library(dplyr) #Warning! Included this library together with plyr results in the situation that summarize() is double defined. Need to be called by dplyr::summarize
library(odbc)
library(factoextra)
library(RColorBrewer)
readRenviron("../env_files/.Renviron.postgres")
```

```{r include=FALSE}
con <- dbConnect(drv=RPostgres::Postgres(),
                 dbname=Sys.getenv("dbname"),
                 host=Sys.getenv("host"),
                 port=Sys.getenv("port"),
                 password=Sys.getenv("password"),
                 user=Sys.getenv("user"))
```

```{r include=FALSE}
con <- DBI::dbConnect(odbc::odbc(),
                      Driver   = Sys.getenv("driver"),#"PostgreSQL Unicode",
                      Server   = Sys.getenv("host"),
                      Database = Sys.getenv("dbname"),
                      UID      = Sys.getenv("user"),
                      PWD      = Sys.getenv("password"),
                      Port     = Sys.getenv("port"))
```



# Todo: tolle Überschrift finden
Es wird ein Clustering unterschiedlicher Daten mit dem K-Means Algorithums vorgenommen.

```{r include=FALSE}
#customers with retail value and amount of orders
käufeProKunde <- dbGetQuery(conn=con, statement = "Select kunde, lieferschein, sum(vk_preis_num) as verkaufswert From verkaeufe Where DATE_PART('week',datum) !=1 OR DATE_PART('week',datum) !=53 Group By kunde,lieferschein")
käufeProKunde <- käufeProKunde %>% ungroup()
käufeProKunde <- käufeProKunde %>% group_by(kunde) %>% dplyr::summarize(bestellungen=n(), verkaufswert=sum(verkaufswert)) %>% arrange(desc(verkaufswert))


#scaled table
käufeProKunde <- käufeProKunde %>% mutate(kunde_sc=scale(kunde), bestellungen_sc=scale(bestellungen), verkaufswert_sc=scale(verkaufswert))
käufeProKunde_scaled <- käufeProKunde %>% select(kunde_sc, bestellungen_sc, verkaufswert_sc)


käufeProKunde_scaled
käufeProKunde
```

## Kundengruppen nach Bestellhäufigkeit und Verkaufswert

Beim Clustering mit K-means stellt sich zunächst die Frage, wie viele Cluster gebildet werden sollen. Die Menge der Cluster wird nicht vom Clustering Algorithmus slebst berechnet und stellt stattdessen einen Parameter für diesen dar. Um besser entscheiden zu können, wie viele Cluster sinnvoll wären, wird eine Methode zur Cluster Validierung genutzt - Ellbow Method.
Die resultierende Kurve sinkt asymptopisch ab. Hirbei wird der Punkt als optimale Cluster Anzahl betrachtet, bei dem die Kurve beginnt sich abzuflachen.
Daraus schließen wir die eine Clustermenge von 4.

```{r echo=FALSE}
# Fancy K-Means
#we cut a few out of the table for this analysis [1:5000, ], else the function wont operate cause to a to big memory usage
fviz_nbclust(käufeProKunde_scaled %>% select(bestellungen_sc,verkaufswert_sc), kmeans, nstart=100, method = "wss")
```

Das Ergebnis des Clustering sieht aus wie folgt:

```{r echo=FALSE}
# Fancy K-Means
kmeans_fancy <- kmeans(käufeProKunde_scaled %>% select(bestellungen_sc,verkaufswert_sc), 4, nstart = 100)
kmeans_fancy
# plot the clusters
fviz_cluster(kmeans_fancy, data = käufeProKunde_scaled %>% select(bestellungen_skaliert=bestellungen_sc,verkaufswert_skaliert=verkaufswert_sc), geom = c("point"),ellipse.type = "convex")
```


```{r include=FALSE}
#add the results to the primary table
cluster_data <- cbind(käufeProKunde, cluster = kmeans_fancy$cluster)
cluster_data
```


```{r include=FALSE}
#get the summarised values for each cluster
sumOfClusters <- final_data %>% select(cluster,verkaufswert,bestellungen)
meanVerkaufswert <- mean(sumOfClusters$verkaufswert)
meanBestellungen <- mean(sumOfClusters$bestellungen)
amountVerkaufswert <- length(sumOfClusters$verkaufswert)
amountBestellungen <- length(sumOfClusters$bestellungen)
sumVerkaufswert <- sum(sumOfClusters$verkaufswert)
sumBestellungen <- sum(sumOfClusters$bestellungen)
  
sumOfClusters <- sumOfClusters %>% group_by(cluster) %>% dplyr::summarize(
  verkaufswertDesClusters=sum(verkaufswert),
  verkaufswert_rel=verkaufswertDesClusters/(sumVerkaufswert/100),
  verkaufswert_avg_imCluster=mean(verkaufswert),
  bestellungenDesClusters=sum(bestellungen),
  bestellungen_rel=bestellungenDesClusters/(sumBestellungen/100),
  bestellungen_avg_imCluster=mean(bestellungen),
  kunden=n())
sumOfClusters
```

Wir ordnen die Cluster nach ihrer Größe und es wird auffällig, dass einer die Cluster mit weitem Abstand die Dominanteste ist und damit die meisten Kunden zu ihm gehören.

```{r echo=FALSE}
#Bar diagramm for total and rel. retail value per cluster
ggplot(sumOfClusters %>% select(cluster,kunden), aes(x=cluster, y=kunden)) +
  geom_bar(stat="identity", fill="steelblue")+
  geom_text(aes(label=kunden), vjust=-0.3, size=3.5)+
  theme_minimal()
```

Betrachten wir aber dazu noch den tatsächlichen Umsatz der jeweiligen Gruppen fällt auf, dass die beiden kleinsten Gruppen mit nur 14 bzw. 0.26 % der järhlichen Kunden zusammen für 25% des Umsatzes verantwortlich sind.

```{r echo=FALSE}
#Bar diagramm for total and rel. retail value per cluster
ggplot(sumOfClusters %>% select(cluster,verkaufswertDesClusters,verkaufswert_rel), aes(x=cluster, y=verkaufswertDesClusters)) +
  geom_bar(stat="identity", fill="steelblue")+
  geom_text(aes(label=paste(as.character(round(verkaufswert_rel, digits = 2)),"%")), vjust=+3, size=3.5)+
  geom_text(aes(label=verkaufswertDesClusters), vjust=+1.3, size=3.5)+
  theme_minimal()
```

```{r include=FALSE}
dbDisconnect(con)
```