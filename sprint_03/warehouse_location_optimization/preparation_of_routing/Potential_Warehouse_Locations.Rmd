---
title: "Ermittlung potenzieller Lagerstandorte"
author: "Alexander Opris, Felix Mayer, Lukas Felzmann"
output:
  html_notebook:
    toc: true
    toc_float: true
    code_folding: none
    number_sections: true
---



```{r include=FALSE}
library(DBI)
library(odbc)
library(readr)
library(leaflet)
library(dplyr)
library(stringr)
library(glue)
library(tictoc)
readRenviron("../../../env_files/.Renviron.postgres")
```

```{r include=FALSE}
# Verbindung zu unserer Datenbank für das Routing (Name = "routing_db")
con_to_routing_db <- DBI::dbConnect(odbc::odbc(),
                      Driver   = Sys.getenv("driver"),
                      Server   = Sys.getenv("host"),
                      Database = Sys.getenv("dbname_routing"),
                      UID      = Sys.getenv("user"),
                      PWD      = Sys.getenv("password"),
                      Port     = Sys.getenv("port"))

# Verbindung zu unserer Haupt-Datenbank (Name = "postgres")
con_to_normal_db <- DBI::dbConnect(odbc::odbc(),
                      Driver   = Sys.getenv("driver"),
                      Server   = Sys.getenv("host"),
                      Database = Sys.getenv("dbname"),
                      UID      = Sys.getenv("user"),
                      PWD      = Sys.getenv("password"),
                      Port     = Sys.getenv("port"))
```


# Disclaimer: Urheberrecht
Die in den Analysen verwendeten Daten wurden uns von Prof. Dr.-Ing. Martin Wölker ([Hochschul-Profilseite](https://www.hs-kl.de/hochschule/profil/personenverzeichnis/detailanzeige-personen/person/martin-woelker)) zur Verfügung gestellt. Die Daten sind auf Herrn Wölkers Blog ([Martins wahre Logistik](https://martins-wahre-logistik.blogspot.com/2022/10/logistics-case-studies-der-lieferschein.html)) auffindbar. Zum gegenwärtigen Zeitpunkt (Stand: 07.12.2022) sind die Daten wie folgt lizenziert: CC BY-NC-SA







# Raster und potenzielle Lagerstandorte
```{r include=FALSE}
# Funktion zum Berechnen der Distanz zwischen zwei Punkten (sphärische Geometrie wird berücksichtigt)
orthodrome_meters <- function(lat1, long1, lat2, long2) {
  lat1_rad <- lat1*pi/180
  long1_rad <- long1*pi/180
  lat2_rad <- lat2*pi/180
  long2_rad <- long2*pi/180
  
  zeta <- acos(sin(lat1_rad)*sin(lat2_rad)+cos(lat1_rad)*cos(lat2_rad)*cos(long2_rad-long1_rad))
  distance_earth <- zeta*6370000
  
  return(distance_earth)
}
```



```{r include=FALSE}
# Bildung eines Rasters Variante 3
# Die Verjüngung der Erde (zu den Polen hin) wird berücksichtigt. Es wird (bis auf Rundungsfehler) sichergestellt, dass der Abstand benachbarter Rasterpunkte in lat- und long-Richtung überall gleich ist.

de_min_long <- 5.8630797
de_max_long <- 15.0644589 
de_min_lat <- 47.2842067
de_max_lat <- 55.0458651


length_out_lat <- 11
lat_intervall <- seq(from = de_min_lat, to = de_max_lat, length.out = length_out_lat)
length_lat_in_meters <- orthodrome_meters(lat1 = de_min_lat, long1 = 0, lat2 = de_max_lat, long2 = 0)
distance_between_raster_points_in_meters <- length_lat_in_meters / (length_out_lat-1)
raster <- matrix(ncol=2, dimnames=list(c(), c("long", "lat")))

for(i in 1:length(lat_intervall)){
  current_lat <- lat_intervall[i]
  length_long_in_meters <- orthodrome_meters(lat1 = current_lat, long1 = de_min_long, lat2 = current_lat, long2 = de_max_long)
  delta_long <- (distance_between_raster_points_in_meters/length_long_in_meters) * (de_max_long - de_min_long)
  
  
  
  # long_intervall <- seq(from = de_min_long, to = de_max_long, length.out = length_out_long)
  long_intervall <- seq(from = de_min_long, to = (de_max_long + delta_long), by=delta_long)
  raster <- rbind(raster, expand.grid(long=long_intervall, lat=current_lat))
}

raster <- raster[-1,] # Zeile mit NAs (wegen leerer Initialisierung) entfernen
```



```{r echo=FALSE}
# Visualisiere die Punkte des oben erstellten Rasters
leaflet(width = "100%", height = "700px") %>%
  addTiles() %>% 
  addCircleMarkers(lng = raster$long,
                   lat = raster$lat,
                   radius = 6)
```



```{sql connection=con_to_routing_db, include=FALSE}
-- Hilfstabelle "tmp_raster_points" anlegen, in die die Raster-Punkte (aus raster) 1:1 reingeschrieben werden sollen (siehe nächster Code Chunk).
DROP TABLE IF EXISTS tmp_raster_points;

CREATE TABLE tmp_raster_points (
	lat double precision NOT NULL,
	long double precision NOT NULL
);
```



```{r include=FALSE}
# Schreibe die Raster-Punkte 1:1 in die Hilfstabelle "tmp_raster_points"
dbAppendTable(conn=con_to_routing_db, name = "tmp_raster_points", value=raster)
```


```{r echo=FALSE}
# Zum Testen
# tmp_raster <- dbGetQuery(conn = con_to_routing_db, statement="select * from tmp_raster_points")
# leaflet(width="100%") %>%
#   addTiles() %>% 
#   addCircleMarkers(lng = tmp_raster$long, lat = tmp_raster$lat)
```


```{sql connection=con_to_routing_db, include=FALSE}
-- Anlegen der Tabelle für die potenziellen Lagerstandorte
DROP TABLE IF EXISTS potential_warehouse_locations;

CREATE TABLE potential_warehouse_locations (
  proj_vertice_id integer primary key,
	proj_lat double precision NOT NULL,
	proj_long double precision NOT NULL,
	proj_the_geom geometry NOT NULL,
	original_lat double precision NOT NULL,
	original_long double precision NOT NULL
);
```



```{sql connection=con_to_routing_db, include=FALSE}
-- Hier passieren die folgenden Schritte:
-- 1. Für jeden unserer Rasterpunkte suchen wir den nächstgelegenden Knoten aus unserer routing_db.
-- 2. Ein paar Aliase einführen.
-- 3. Das Ergebnis schreiben wir in die Tabelle "potential_warehouse_locations"
INSERT INTO potential_warehouse_locations(proj_vertice_id, proj_long, proj_lat, proj_the_geom, original_lat, original_long)
SELECT DISTINCT ON (id)
        id AS proj_vertice_id, proj_long, proj_lat, the_geom AS proj_the_geom, lat AS original_lat, long AS original_long
FROM tmp_raster_points AS raster_points
CROSS JOIN LATERAL (
	SELECT id,
			the_geom,
			ST_X(the_geom) AS proj_long,
			ST_Y(the_geom) AS proj_lat,
			vertices.the_geom <-> ST_SetSRID(ST_MakePoint(raster_points.long, raster_points.lat), 4326) AS dist
	FROM de_edges_vertices_pgr AS vertices
	ORDER BY dist
	LIMIT 1
)  AS vertices;
```



```{r echo=FALSE}
potential_warehouse_locations <- dbGetQuery(conn = con_to_routing_db, statement = "select * from potential_warehouse_locations")

leaflet(width = "100%", height = "700px") %>%
  addTiles() %>%
  addCircleMarkers(lng = potential_warehouse_locations$proj_long,
                   lat = potential_warehouse_locations$proj_lat,
                   radius = 6)
```