---
title: "Standort für das Zentrallager"
author: "Alexander Opris, Felix Mayer, Lukas Felzmann"
output:
  html_notebook:
    toc: true
    toc_float: true
    code_folding: none
    number_sections: true
---



```{r include=FALSE}
library(DBI)
library(odbc)
library(readr)
library(leaflet)
library(dplyr)
library(stringr)
library(glue)
library(tictoc)
readRenviron("../../env_files/.Renviron.postgres")
```

```{r include=FALSE}
width_for_leaflet_maps <- "100%"
height_for_leaflet_maps <- "80vh"
```


```{r include=FALSE}
get_con_to_routing_db <- function(){
  con_to_routing_db <- DBI::dbConnect(odbc::odbc(),
                      Driver   = Sys.getenv("driver"),
                      Server   = Sys.getenv("host"),
                      Database = Sys.getenv("dbname_routing"),
                      UID      = Sys.getenv("user"),
                      PWD      = Sys.getenv("password"),
                      Port     = Sys.getenv("port"))
  
  return(con_to_routing_db)
}

get_con_to_normal_db <- function(){
  con_to_normal_db <- DBI::dbConnect(odbc::odbc(),
                      Driver   = Sys.getenv("driver"),
                      Server   = Sys.getenv("host"),
                      Database = Sys.getenv("dbname"),
                      UID      = Sys.getenv("user"),
                      PWD      = Sys.getenv("password"),
                      Port     = Sys.getenv("port"))
  
  return(con_to_normal_db)
}
```

```{r include=FALSE}
# Funktion zum Berechnen der Distanz zwischen zwei Punkten (sphärische Geometrie wird berücksichtigt)
orthodrome_meters <- function(lat1, long1, lat2, long2) {
  lat1_rad <- lat1*pi/180
  long1_rad <- long1*pi/180
  lat2_rad <- lat2*pi/180
  long2_rad <- long2*pi/180
  
  zeta <- acos(sin(lat1_rad)*sin(lat2_rad)+cos(lat1_rad)*cos(lat2_rad)*cos(long2_rad-long1_rad))
  distance_earth <- zeta*6370000
  
  return(distance_earth)
}
```



# Disclaimer: Urheberrecht
Die in den Analysen verwendeten Daten wurden uns von Prof. Dr.-Ing. Martin Wölker ([Hochschul-Profilseite](https://www.hs-kl.de/hochschule/profil/personenverzeichnis/detailanzeige-personen/person/martin-woelker)) zur Verfügung gestellt. Die Daten sind auf Herrn Wölkers Blog ([Martins wahre Logistik](https://martins-wahre-logistik.blogspot.com/2022/10/logistics-case-studies-der-lieferschein.html)) auffindbar. Zum gegenwärtigen Zeitpunkt (Stand: 07.12.2022) sind die Daten wie folgt lizenziert: CC BY-NC-SA



# Vorbereitungen
## Raster
Wir haben ein gleichmäßiges Raster über Deutschland gelegt.

```{r include=FALSE}
con_to_routing_db <- get_con_to_routing_db()
query <- "SELECT * FROM tmp_raster_points"
raster_points <- dbGetQuery(conn = con_to_routing_db, statement = query)
dbDisconnect(con_to_routing_db)
```

```{r echo=FALSE}
leaflet(width = width_for_leaflet_maps, height = height_for_leaflet_maps) %>% 
  addTiles() %>% 
  addCircleMarkers(lat = raster_points$lat,
                   lng = raster_points$long,
                   radius = 6)
```

Das Raster umfasst `r raster_points %>% nrow()` Punkte, die sowohl in x- als auch y-Richtung jeweils einen Abstand von ca. TODO haben.



## Standortkandidaten
Wir haben die Rasterpunkte auf Straßen in Deutschland abgebildet.

```{r include=FALSE}
con_to_routing_db <- get_con_to_routing_db()
query <- "SELECT * FROM potential_warehouse_locations"
potential_warehouse_locations <- dbGetQuery(conn = con_to_routing_db, statement = query)
dbDisconnect(con_to_routing_db)
```

```{r echo=FALSE}
leaflet(width = width_for_leaflet_maps, height = height_for_leaflet_maps) %>%  
  addTiles() %>% 
  addCircleMarkers(lat = potential_warehouse_locations$proj_lat,
                   lng = potential_warehouse_locations$proj_long,
                   radius = 6)
```
Beim Mapping sind zum Teil auch verschiedene Rasterpunkte auf denselben Straßenknoten abgebildet worden. Deshalb wurde aus den `r raster_points %>% nrow()` Rasterpunkten `r potential_warehouse_locations %>% nrow()` Standortkandidaten in Deutschland.

**Todo: Vielleicht noch beispielhaft an ein paar Rasterpunkten das Mapping mit Pfeilen zeigen.**

## Kundenclustering
Um die Anzahl der zu berechnenden Routen zu reduzieren, sollen die Kunden, die nahe beieinander, zu einem Cluster zusammengefasst werden. Glücklicherweise liegen die Kunden schon "von Haus aus" in  `r customer_cluster_proj %>% distinct(original_lat, original_long) %>% nrow()` Clustern vor. Die Cluster-Koordinaten müssen ebenfalls auf die Straße abgebildet werden.


```{r include=FALSE}
con_to_routing_db <- get_con_to_routing_db()
query <- "SELECT * FROM customer_cluster_proj"
customer_cluster_proj <- dbGetQuery(conn = con_to_routing_db, statement = query)
dbDisconnect(con_to_routing_db)
```

```{r echo=FALSE}
leaflet(width = width_for_leaflet_maps, height = height_for_leaflet_maps) %>%
  addTiles() %>%
  addCircleMarkers(lat = customer_cluster_proj$original_lat,
                   lng = customer_cluster_proj$original_long,
                   radius = 6,
                   color = "blue") %>% 
  addCircleMarkers(lat = customer_cluster_proj$proj_lat,
                   lng = customer_cluster_proj$proj_long,
                   radius = 6,
                   color = "red")
```
Nach der Abbildung auf Knoten unseres Straßennetzwerks liegen `r customer_cluster_proj %>% distinct(proj_vertex_id) %>% nrow()` Koordinaten vor.


Todo:

1. Vielleicht noch eine Legende an die Karte (Was bedeuten rote/blaue Kreise?)


### Kunden ohne Kundenstammdaten
Es gibt Kunden in unseren Verkaufsdaten, zu denen wir keine Stammdaten haben. Zu diesen Kunden können wir also keine Route berechnen.

```{r include=FALSE}
con_to_normal_db <- get_con_to_normal_db()
query <- "
          SELECT DISTINCT(kunde) AS kndnr
          FROM verkaeufe
          
          EXCEPT
          
          SELECT DISTINCT(kndnr_tagless) AS kndnr
          FROM kundenstammdaten;
        "


kunden_ohne_kundenstammdaten <- dbGetQuery(conn = con_to_normal_db, statement = query)
dbDisconnect(con_to_normal_db)
```


```{r include=FALSE}
con_to_normal_db <- get_con_to_normal_db()
query <- "
          SELECT kunde as kndnr, SUM(vk_preis_num) AS umsatz_durch_kunde
        	FROM verkaeufe
        	GROUP BY kunde;
        "


umsatz_je_kunde <- dbGetQuery(conn = con_to_normal_db, statement = query)
dbDisconnect(con_to_normal_db)
```



```{r include=FALSE}
anteile_der_kunden_ohne_stammdaten_am_umsatz <- 
  umsatz_je_kunde %>% 
  mutate(anteil_am_umsatz = umsatz_durch_kunde/sum(umsatz_durch_kunde)) %>% 
  arrange(desc(anteil_am_umsatz)) %>% 
  mutate(kumulierter_anteil = cumsum(anteil_am_umsatz)) %>% 
  inner_join(kunden_ohne_kundenstammdaten, by = "kndnr") %>% 
  arrange(kumulierter_anteil)
```

```{r echo=FALSE}
anteile_der_kunden_ohne_stammdaten_am_umsatz %>% 
  mutate(
    anteil_in_prozent = round(anteil_am_umsatz*100, digits = 2),
    kumulierter_anteil_in_prozent = round(kumulierter_anteil*100, digits = 2)
    ) %>% 
  select(kndnr, umsatz_durch_kunde, anteil_in_prozent, kumulierter_anteil_in_prozent)
```
Die betreffenden Kunden gehören nicht zu unseren umsatzstarken Kunden. Selbst zusammen machen sie gerade einmal `r sum(anteile_der_kunden_ohne_stammdaten_am_umsatz$anteil_am_umsatz) * 100` am Gesamtumsatz aus.

Todo: Vielleicht noch schauen, zu welchen Prozent der umsatzschwachen Kunden sie gehören
Todo: Vielleicht diese Kunden auch nochmal hinsichtlich Bestellungen anschauen

















## Routenberechnung
Todo:

1. ein paar Beispielrouten (vielleicht zu zwei Lagerkandidaten) visualisieren
1. Dann erklären, was wir mit diesen Routen gemacht haben
1. vllt. nochmal eine Visualisierung: gerade Linien von einem Lagerkandidat zu den Kundenclustern mit der Strecklänge als Kosten an der Linie



# Auswertung der Routing-Ergebnisse
Todo:

1. ... Ergebnisse der Analysen hinsichtlich Distanz, Distanz & Umsatz, Distanz & #Bestellung, ...
Todo:Achtung: Nicht die Gewichtung der Cluster vergessen






```{r include=FALSE}
con_to_normal_db <- get_con_to_normal_db()

query <- "
          SELECT 
          	umsatz_pro_kunde.kndnr,
          	summe_umsatz,
          	anzahl_lieferungen,
          	laengengrad AS long,
          	breitengrad AS lat
          FROM
          
          (
          	SELECT kunde AS kndnr, SUM(vk_preis_num) AS summe_umsatz
          	FROM verkaeufe
          	GROUP BY kunde
          ) AS umsatz_pro_kunde
          
          INNER JOIN
          
          (
          	SELECT kunde AS kndnr, COUNT(DISTINCT(datum, lieferschein)) AS anzahl_lieferungen
          	FROM verkaeufe
          	GROUP BY kunde
          ) AS bestellungen_pro_kunde
          USING (kndnr) 
          
          INNER JOIN
          
          kundenstammdaten
          ON bestellungen_pro_kunde.kndnr = kundenstammdaten.kndnr_tagless;
        "


customer_data_aggregated <- dbGetQuery(conn = con_to_normal_db, statement = query)
dbDisconnect(con_to_normal_db)
```



```{r include=FALSE}
customer_cluster_data_enhanced <- 
  customer_cluster_proj %>% 
  inner_join(customer_data_aggregated, by = c("original_lat" = "lat", "original_long" = "long")) %>% 
  group_by(proj_vertex_id) %>% 
  summarise(summe_umsatz = sum(summe_umsatz),
            anzahl_lieferungen = sum(anzahl_lieferungen),
            anzahl_kunden_im_cluster = n())
```


```{r include=FALSE}
con_to_normal_db <- get_con_to_normal_db()
query <- "
          SELECT *
          FROM routing_agg_results
          ;
        "


routing_agg_results <- dbGetQuery(conn = con_to_normal_db, statement = query)
dbDisconnect(con_to_normal_db)
```




```{r}
routing_agg_results_enhanced <-
  routing_agg_results %>% 
  inner_join(customer_cluster_data_enhanced, by = c("end_vid" = "proj_vertex_id"))
```







Todo: Irgendwas stimmt bei customer_cluster_data_enhanced noch mit Umsatz und Anzahl Bestellungen nicht --> nochmal checken

















## Kriterium: Distanz
Welche Lager weisen im Durchschnitt eine geringe Distanz zum Kunden auf?
```{r include=FALSE}
# Die Distanz zu jedem Cluster muss noch mit der Anzahl der Kunden im jeweiligen Cluster gewichtet werden.
# Achtung: Für den Durchschnitt nicht einfach avg() verwenden. Das würde in diesem Fall durch die Anzahl der Cluster und nicht (wie gewollt) durch die Anzahl der Kunden teilen.
auswertung_nach_distanz <-
  routing_agg_results_enhanced %>% 
  mutate(gew_km_start_end = km_start_end*anzahl_kunden_im_cluster,
         gew_km_end_start = km_end_start*anzahl_kunden_im_cluster) %>% 
  group_by(start_vid,
           proj_start_lat,
           proj_start_long) %>% 
  summarise(km_start_end_avg = sum(gew_km_start_end)/sum(anzahl_kunden_im_cluster),
            km_end_start_avg = sum(gew_km_end_start)/sum(anzahl_kunden_im_cluster))
```


```{r echo=FALSE}
auswertung_nach_distanz %>% 
  arrange(km_start_end_avg)
```


```{r echo=FALSE}
leaflet(width = width_for_leaflet_maps, height = height_for_leaflet_maps) %>%
  addTiles() %>%
  addCircleMarkers(lat = auswertung_nach_distanz[1:5,]$proj_start_lat,
                   lng = auswertung_nach_distanz[1:5,]$proj_start_long,
                   radius = 6,
                   ) 
```






## Kriterium: Anzahl Lieferungen
Todo


## Kriterium: Umsatz
Todo




## Ausblick
- Gewicht
- Volumen










# Plausi-Checks und Co
Todo:

1. Es gibt Kunden, zu denen wir keine Route gefunden haben. Wie wichtig sind diese hinsichtlich Umsatz, Anzahl Bestellungen etc.?
1. Es gibt Kunden, die kommen in unserer Kundenstammdaten-Tabelle nicht vor. Zu diesen können wir logischerweise auch keine Routen berechnen, da uns die Standort-Koordinaten fehlen. Wie wichtig sind diese hinsichtlich Umsatz, Anzahl Bestellungen etc.?




# Playground (Todo: noch raus damit)
```{r}
lats = seq(from=40, to=45, length.out=20)
lons = rep(12, 20)
```

```{r}
lons
```


```{r echo=FALSE}
leaflet(width = width_for_leaflet_maps, height = height_for_leaflet_maps) %>% 
  addTiles() %>% 
  addCircleMarkers(lat = lats,
                   lng = lons,
                   radius = 6)
```


```{r echo=FALSE}
leaflet(width = width_for_leaflet_maps, height = height_for_leaflet_maps) %>% 
  addTiles() %>% 
  addCircleMarkers(lat = lats,
                   lng = lons,
                   radius = 6)
```




