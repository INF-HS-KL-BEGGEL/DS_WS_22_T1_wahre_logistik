---
title: "Standort für das Zentrallager"
author: "Alexander Opris, Felix Mayer, Lukas Felzmann"
output:
  html_notebook:
    toc: true
    toc_float: true
    code_folding: none
    number_sections: true
---



```{r include=FALSE}
library(DBI)
library(odbc)
library(readr)
library(leaflet)
library(dplyr)
library(stringr)
library(glue)
library(tictoc)
readRenviron("../env_files/.Renviron.postgres")
```

```{r include=FALSE}
# Verbindung zu unserer Datenbank für das Routing (Name = "routing_db")
con_to_routing_db <- DBI::dbConnect(odbc::odbc(),
                      Driver   = Sys.getenv("driver"),
                      Server   = Sys.getenv("host"),
                      Database = Sys.getenv("dbname_routing"),
                      UID      = Sys.getenv("user"),
                      PWD      = Sys.getenv("password"),
                      Port     = Sys.getenv("port"))

# Verbindung zu unserer Haupt-Datenbank (Name = "postgres")
con_to_normal_db <- DBI::dbConnect(odbc::odbc(),
                      Driver   = Sys.getenv("driver"),
                      Server   = Sys.getenv("host"),
                      Database = Sys.getenv("dbname"),
                      UID      = Sys.getenv("user"),
                      PWD      = Sys.getenv("password"),
                      Port     = Sys.getenv("port"))
```


# Disclaimer: Urheberrecht
Die in den Analysen verwendeten Daten wurden uns von Prof. Dr.-Ing. Martin Wölker ([Hochschul-Profilseite](https://www.hs-kl.de/hochschule/profil/personenverzeichnis/detailanzeige-personen/person/martin-woelker)) zur Verfügung gestellt. Die Daten sind auf Herrn Wölkers Blog ([Martins wahre Logistik](https://martins-wahre-logistik.blogspot.com/2022/10/logistics-case-studies-der-lieferschein.html)) auffindbar. Zum gegenwärtigen Zeitpunkt (Stand: 07.12.2022) sind die Daten wie folgt lizenziert: CC BY-NC-SA






# Raster
```{r}
orthodrome_meters <- function(lat1, long1, lat2, long2) {
  lat1_rad <- lat1*pi/180
  long1_rad <- long1*pi/180
  lat2_rad <- lat2*pi/180
  long2_rad <- long2*pi/180
  
  zeta <- acos(sin(lat1_rad)*sin(lat2_rad)+cos(lat1_rad)*cos(lat2_rad)*cos(long2_rad-long1_rad))
  distance_earth <- zeta*6370000
  
  return(distance_earth)
}
```



```{r}
# Bildung eines Rasters Variante 1
# Verjüngung der Erde zu den Polen hin wird NICHT berücksichtigt
# Unterschied zwischen Längengraden im Norden und Süden: 18,5 %
de_min_long <- 5.8630797
de_max_long <- 15.0644589 
de_min_lat <- 47.2842067
de_max_lat <- 55.0458651
de_long_mid <- (de_max_long + de_min_long)/2
de_lat_mid <- (de_max_lat + de_min_lat)/2

length_long_in_meters <- orthodrome_meters(lat1 = de_lat_mid, long1 = de_min_long, lat2 = de_lat_mid, long2 = de_max_long)
length_lat_in_meters <- orthodrome_meters(lat1 = de_min_lat, long1 = de_long_mid, lat2 = de_max_lat, long2 = de_long_mid)

ratio_lat_long <- length_lat_in_meters/length_long_in_meters
# ratio_lat_long <- (de_max_lat - de_min_lat) / (de_max_long - de_min_long)
# ratio_lat_long <- 1.244206

length_out_long <- 10 # Todo: muss noch sinnvoll gewählt werden (nicht zu groß, sonst zu viele Routen)
length_out_lat <- ceiling(length_out_long * ratio_lat_long)

long_intervall <- seq(from = de_min_long, to = de_max_long, length.out = length_out_long)
lat_intervall <- seq(from = de_min_lat, to = de_max_lat, length.out = length_out_lat)

raster <- expand.grid(long=long_intervall, lat=lat_intervall)
```



```{r}
leaflet(width="100%") %>%
  addTiles() %>% 
  addCircleMarkers(lng = raster$long, lat = raster$lat)
```







```{r}
# Bildung eines Rasters Variante 2
# Die Verjüngung der Erde (zu den Polen hin) wird berücksichtigt. Allerdings werden die Knoten in einer Ebene (also je Breitengrad) gleichmäßig verteilt, wodurch der Abstand zwischen zwei Punkten in verschiedenen Breitengraden immer noch unterschiedlich ausfallen kann. Dieser Effekt macht sich vor allem bei einer geringen Anzahl an Rasterpunkten bemerkbar.
de_min_long <- 5.8630797
de_max_long <- 15.0644589 
de_min_lat <- 47.2842067
de_max_lat <- 55.0458651


length_out_lat <- 14
lat_intervall <- seq(from = de_min_lat, to = de_max_lat, length.out = length_out_lat)
length_lat_in_meters <- orthodrome_meters(lat1 = de_min_lat, long1 = 0, lat2 = de_max_lat, long2 = 0)
raster <- matrix(ncol=2, dimnames=list(c(), c("long", "lat")))

for(i in 1:length(lat_intervall)){
  current_lat <- lat_intervall[i]
  length_long_in_meters <- orthodrome_meters(lat1 = current_lat, long1 = de_min_long, lat2 = current_lat, long2 = de_max_long)
  ratio_long_lat <- length_long_in_meters/length_lat_in_meters
  length_out_long <- ceiling(length_out_lat * ratio_long_lat)
  long_intervall <- seq(from = de_min_long, to = de_max_long, length.out = length_out_long)
  raster <- rbind(raster, expand.grid(long=long_intervall, lat=current_lat))
}

raster <- raster[-1,] # Zeile mit NAs (wegen leerer Initialisierung) entfernen
```



```{r}
leaflet(width="100%") %>%
  addTiles() %>% 
  addCircleMarkers(lng = raster$long, lat = raster$lat)
```












```{r}
# Bildung eines Rasters Variante 3
# Die Verjüngung der Erde (zu den Polen hin) wird berücksichtigt. Es wird (bis auf Rundungsfehler) sichergestellt, dass der Abstand benachbarter Rasterpunkte in lat- und long-Richtung überall gleich ist.

de_min_long <- 5.8630797
de_max_long <- 15.0644589 
de_min_lat <- 47.2842067
de_max_lat <- 55.0458651


length_out_lat <- 11
lat_intervall <- seq(from = de_min_lat, to = de_max_lat, length.out = length_out_lat)
length_lat_in_meters <- orthodrome_meters(lat1 = de_min_lat, long1 = 0, lat2 = de_max_lat, long2 = 0)
distance_between_raster_points_in_meters <- length_lat_in_meters / (length_out_lat-1)
raster <- matrix(ncol=2, dimnames=list(c(), c("long", "lat")))

for(i in 1:length(lat_intervall)){
  current_lat <- lat_intervall[i]
  length_long_in_meters <- orthodrome_meters(lat1 = current_lat, long1 = de_min_long, lat2 = current_lat, long2 = de_max_long)
  delta_long <- (distance_between_raster_points_in_meters/length_long_in_meters) * (de_max_long - de_min_long)
  
  
  
  # long_intervall <- seq(from = de_min_long, to = de_max_long, length.out = length_out_long)
  long_intervall <- seq(from = de_min_long, to = (de_max_long + delta_long), by=delta_long)
  raster <- rbind(raster, expand.grid(long=long_intervall, lat=current_lat))
}

raster <- raster[-1,] # Zeile mit NAs (wegen leerer Initialisierung) entfernen
```



```{r}
leaflet(width="100%") %>%
  addTiles() %>% 
  addCircleMarkers(lng = raster$long, lat = raster$lat)
```











# Routing-Funktion
```{r}
calculate_routing_results <- function(start_long, start_lat, end_long, end_lat){
  # Diese Funktion erledigt die folgenden Schritte (innerhalb einer einzigen Query):
  # 1. Es werden die nächstgelegenden Nodes zu start = (start_long, start_lat) und end = (end_long, end_lat) bestimmt. Diese nennen wir im Folgenden proj_start und proj_end.
  # 2. Es werden die Routen proj_start --> proj_end und proj_end --> proj_start berechnet.
  # 3. Es werden die Längen (in Kilometer) dieser beiden Routen berechnet.
  
  # Return: list(
                  # proj_start_long,
                  # proj_start_lat,
                  # proj_end_long,
                  # proj_end_lat,
                  # km_start_end,
                  # km_end_start
                # )
  
  
  # Todo: Implementierung
  stop("The function calculate_routing_results is not yet implemented!")
}
```




# Routing (Todo: bessere Überschrift)
## Bidirektionaler A-Star mit limitierender Bounding Box
```{r echo=FALSE}
bd_a_star_limit_bbox <- function(start_coord, destination_coord) {
  # A-Star mit limitierender Bounding Box
  # Todo: Noch über die anderen Options Gedanken machen (z. B. Heuristik)
  query <-  glue("
            -- Find nearest node to start coordinate
            WITH start as (
          	  SELECT id
            	from de_edges_vertices_pgr
            	order by the_geom <-> ST_SetSRID(ST_MakePoint({start_coord$lon}, {start_coord$lat}), 4326)
            	limit 1
            ),
            
            -- Find nearest node to end coordinate
            destination as (
            	SELECT id
            	from de_edges_vertices_pgr
            	order by the_geom <-> ST_SetSRID(ST_MakePoint({destination_coord$lon}, {destination_coord$lat}), 4326)
            	limit 1
            )
            
            -- Calculate the route
            SELECT *
            FROM pgr_bdAstar(
            'SELECT id,
                    source,
                    target,
                    cost,
                    reverse_cost,
                    x1,
                    y1,
                    x2,
                    y2
            FROM de_edges as e,
            (SELECT ST_Expand(ST_Extent(the_geom), 0.1) as box FROM de_edges as b
            WHERE b.source = '|| (SELECT id FROM start) ||'
            OR b.source = ' || (SELECT id FROM destination) || ') as box WHERE e.the_geom && box.box',
            array(SELECT id FROM start),
            array(SELECT id FROM destination),
            TRUE) as route
            ");
            
  return(dbGetQuery(conn=con, statement = query))
}
```